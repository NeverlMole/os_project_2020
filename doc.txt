. KThread.join()
  Here we need to set the current thread to sleep and weak it up when the
  thread that was called (this) finished executing. Since we also need to
  donate the priority, we use a ThreadQueue called joinQueue to store the one
  that waiting for the current thread.

  New variables defined:
    - private ThreadQueue joinQueue
        : initialized when first calling join

  Specific changes to KThread.join():
    - If the thread (this) is finished, return directly.
    - Check join is not previously called by checking joinQueue is null.
    - View the join as a source, let the thread acquire the source and let the
      current thread wait via joinQueue.
    - Disable interrupt and restore at the end just like KThread.yield().

  Specific changes to KThread.finish():
    - If the current thread has the joinQueue, wake the thread in joinQueue.

  Father-sons test case in KThread.fatherSonsTest():
    - Run father thread and fork several sons thread.
    - Father thread wait for each son to finish before forking another son.
    - Father thread wait for sons to finish after forking all sons.
    - The purpose is to test whether the father thread could wait for each son
      thread to finish correctly and also whether the father thred could
      return immediately if the joining son has already finished.

. Condition2
  We direct use the same implementation as in Condition, except we replace
  the semaphore operations by the operations of KThread. More specificly,
  replace P() by sleep and V() by ready. The corretness can be checked by
  comparing the commands executed in the two situation. Also, we need to
  disable interrupt and restore the interrupt in the similar way as that in
  Semaphore.

. Alarm
  We use a list to store the threads waiting and their wake up time. Then, we
  wake up all threads that are eady to wake up in timerInterrupt. We could
  realize the sleep-wake of a thread in the similar way as in the implementa-
  -tion of Condition2.

  New variables defined:
    - private list<KThread, long> waitingQueue
        : initialized when first calling a alarm is construct

  Specific changes to waitUntil():
    - Add current thread and wakeTime to waitingQueue.
    - Let current thread sleep.

  Specific changes to timerInterrupt():
    - Wake all the thread in waitingQueue with wakeTime greater than machine
      time before the current thread yield.

  Clocks test case in clocksTest():
    - Let several threads to sleep for a while and check theirs wake-up time.
    - The purpose is to test whether the alarm could act properly.

. Communicator
  We could view the communicator as communicating via a channel such that each
  time only one speaker and one listener could use the channel and also the
  channel has no buffer, which means only when both speaker and listener use
  the channel the message could send.

  Therefore, we use four condition variables in a communicator, that is:
    - listenChannel, representing a listener could use the channel.
    - speakChannel, representing a speaker could use the channel.
    - speakerSended, representing the speaker using the channel sended its
      message to the channel.
    - listenerReceived, representing the listener using the channel received
      the message sent by the speaker.

  Also, we use a variable buf to present the message trying to send by the
  speaker that use the channel.

  When a new listener comes, if there are other listeners not finishing, let it
  wait for listenChannel. Otherwise, or in the cases that it is woken up from
  listenChannel, which means it could use the channel, check whether a message
  is sent from the channel. If not, let it wait for speakerSended until a
  message is sent from the channel. Then, let it make a response and wake up
  the speaker waiting for listenerReceived.

  When a new speaker comes, if there are other speakers not finishing, let it
  wait for speakChannel. Otherwise, or in the cases that it is woken up from
  speakChannel, which means it could use the channel, let it send a message to
  the channel by putting the message in buf and wake up the listener waiting
  for speakerSended. Then, let the speaker wait for listenerReceived. The
  speaker finishes when it receives the response from the listener.

. PriorityScheduler
  The situations that efficientPriority of a thread might change are:
    - It receives a donation from another thread. Then it should update its own
      efficientPriority. If its own efficientPriority increase, it continues to
      donate the priority to the thread that it is waiting for.
    - It acquires a new sources and its efficientPrioirity should be updated by
      the maximum of the efficientPriority of the corresponding waitQueue. Note
      here we don't need to continue to donate the priority since the thread
      must not be blocked by others.
    - It release a new sources and its efficentPriority should be recalculated.
      Similarly to above case, we don't need to update the efficientPriority
      of other here.
    - Its priority is changed by setPrioirty. Here we need to recalculate the
      efficientPrioirty and also update all the efficient prioity of threads
      affected by its donation.


. Some other modification on the original code.
  - Check the status of the current thread is not running.
  - Change one line yield(); to KThread.yield(); in KThread class.

. Note
  - All the check should be use Lib.assertTrue.

. Strange stuff found
  - The Lock and Semaphore use the waitQueue with priority but Condition not.
